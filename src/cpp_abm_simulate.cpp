
#include <Rcpp.h>
#include <cmath>
#include "cpp_vonmises.h"
#include "cpp_sample_options.h"
#include "cpp_cycle_draw.h"
#include "cpp_get_values.h"

//' @name cpp_abm_simulate
//' @title cpp_abm_simulate
//' @description The C++ function that runs the agent based animal movement model.
//' @param startx The x coord start location
//' @param starty The y coord start location
//' @param steps The number of steps to be simulated
//' @param des_options
//' @param options The number of options to be considered at each step
//' @param k_step Parameter describing step length
//' @param s_step Parameter describing step
//' @param mu_angle Parameter describing angle
//' @param k_angle Parameter describing angle variation
//' @param b0_Options Behave transitional probs for behave 0
//' @param b1_Options Behave transitional probs for behave 1
//' @param b2_Options Behave transitional probs for behave 2
//' @param rest_Cycle_A The amplitude of the resting/active cycle.
//' @param rest_Cycle_M The cycle offset from 0 (Midline Statistic Of Rhythm) of the resting/active cycle.
//' @param rest_Cycle_PHI The offset of the cycle (\eqn{\phi}; i.e., acrophase) of the resting/active cycle.
//' @param rest_Cycle_TAU Cycle frequency (\eqn{\tau}; i.e., period) of the resting/active cycle.
//' @param memShelterMatrix
//' @param forageMatrix
//' @param move_Options
//' @param seeds A number of seeds the length of the number of steps, ideally generated by R handling function.
//' @return A list of simulated animal details to be passed and handled by R function to make easier to use.
//' @details Requires cmath and headers for smaller C++ functions for draws.

// [[Rcpp::export]]
Rcpp::List cpp_abm_simulate(
    double startx,
    double starty,
    int steps,
    int des_options,
    int options,
    std::vector<double> k_step,
    std::vector<double> s_step,
    std::vector<double> mu_angle,
    std::vector<double> k_angle,
    std::vector<double> b0_Options,
    std::vector<double> b1_Options,
    std::vector<double> b2_Options,
    double rest_Cycle_A,
    double rest_Cycle_M,
    double rest_Cycle_PHI,
    double rest_Cycle_TAU,
    Rcpp::NumericMatrix memShelterMatrix,
    Rcpp::NumericMatrix forageMatrix,
    Rcpp::NumericMatrix moveMatrix,
    std::vector<int> seeds
){

  int n = steps;
  int ndes = des_options;
  int nopt = options;

  // location for the step and angle for each choice or desination
  double angle;
  double step;

  // a means of converting NumVec to std::vec
  double vmdraw;

  // Rcpp::NumericVector envVal1(nopt);
  // std::vector<double> envVal1(nopt);

  // Rcpp::NumericVector choicesVec(nopt);
  // std::vector<int> choicesVec(nopt);
  // std::iota (std::begin(choicesVec), std::end(choicesVec), 0); // Fill with 0, 1, ..., end.

  // MOVEMENT OPTIONS OBJECTS --------------------------------------------------
  // the options stores for the loop
  std::vector<double> x_Options(nopt);
  std::vector<double> y_Options(nopt);
  std::vector<int> step_Options(nopt);
  std::vector<double> move_Options(nopt);
  // needed for the chosing of option
  // double min, curr;
  int chosen;
  // store the chose at each step
  std::vector<int> chosen_Options(steps);
  //----------------------------------------------------------------------------

  // the options stores for the output including all options
  // Rcpp::NumericMatrix optionsMatrixALL(nopt*steps +1, 3);
  std::vector<double> x_OptionsAll(nopt*steps);
  std::vector<double> y_OptionsAll(nopt*steps);
  std::vector<int> step_OptionsAll(nopt*steps);

  // REALISED MOVEMENT OBJECTS
  // Rcpp::NumericMatrix locMatrix(steps, 2);
  std::vector<double> x_Locations(steps);
  std::vector<double> y_Locations(steps);
  std::vector<int> step_Locations(steps);
  //----------------------------------------------------------------------------

  // BEHAVIOUR RELATED OBJECTS -------------------------------------------------
  // somewhere to store the behaviours at each step
  std::vector<int> behave_Locations(steps);
  double behave_k_step;
  double behave_s_step;
  double behave_mu_angle;
  double behave_k_angle;

  // something that store the time adjusted behavioural shifts
  // and initialise them with the provided base values
  std::vector<double> b0_Options_Current = b0_Options;
  std::vector<double> b1_Options_Current = b1_Options;
  std::vector<double> b2_Options_Current = b2_Options;

  /* initial behaviour set to 0 */
  behave_Locations[0] = 1;
  // and set a basic behave switch balance for testing
  // std::vector<double> behave_Options = {0.2, 0.2, 0.1};

  // CYCLE MODIFIERS
  double b0_dailyMod;
  //----------------------------------------------------------------------------


  // DESINTATION OBJECTS -------------------------------------------------------
  int chosenDes;
  Rcpp::NumericMatrix desMatrix;
  std::vector<double> x_DesOptions(ndes);
  std::vector<double> y_DesOptions(ndes);
  std::vector<double> land_DesOptions(ndes);
  // object for checking whether the animal should slow down because it's near
  // the destination
  double currDist;
  // a vector to hold the distance between options and the desintation
  double c_dist2;
  std::vector<double> distance_toDes(nopt);
  double distInvert;
  std::vector<double> weights_toDes(nopt);
  // target destinations
  std::vector<double> desX_Locations(steps);
  std::vector<double> desY_Locations(steps);
  std::vector<double> desDist_Locations(steps);
  //----------------------------------------------------------------------------


  /* initial location is set using the start locations */
  x_Locations[0] = startx;
  y_Locations[0] = starty;
  x_OptionsAll[0] = startx;
  y_OptionsAll[0] = starty;
  step_OptionsAll[0] = 0;
  desX_Locations[0] = startx;
  desY_Locations[0] = starty;

  for(int i = 1, a = 1; i < n; i++){
    Rcpp::Rcout << "---- Step: " << i << " ----\n";

    Rcpp::Rcout << "--- Step start set" << " ---\n";

    /* working under the assumption that i == minute, but the cycle is defined in
     hours AKA 12 hour cycle offset to be crepusclar, we need to convert i AKA minute to hours */
    b0_dailyMod = cpp_cycle_draw(
      i*1.0 / 60, // make i a double and convert it to hours
      rest_Cycle_A,
      rest_Cycle_M,
      rest_Cycle_PHI / rest_Cycle_TAU, // make sure PHI is kept ~ to TAU so no drift
      rest_Cycle_TAU);

    /* switch to use a given set of transition probabilities that change
     depending on the previous behavioural state*/
    switch(behave_Locations[i-1]){
      case 0:
        // this will update the behaviour shift prob depending on the time of day
        b0_Options_Current[0] = b0_Options[0] + b0_dailyMod;
        // draw from the updated behaviour probs to get the next behavioural state
        behave_Locations[i] = cpp_sample_options(b0_Options_Current, seeds[i-1]);
        break;
      case 1:
        b1_Options_Current[0] = b1_Options[0] + b0_dailyMod;
        behave_Locations[i] = cpp_sample_options(b1_Options_Current, seeds[i-1]);
        break;
      case 2:
        b2_Options_Current[0] = b2_Options[0] + b0_dailyMod;
        behave_Locations[i] = cpp_sample_options(b2_Options_Current, seeds[i-1]);
        break;
        // default:
        //   behave_Locations[i] = sample_options(b0_Options, seeds[i-1]);
        //   break;
    }

    /* assigning the step and angle parameters
     depending on the behaviour */
    switch(behave_Locations[i]){
      case 0:
        behave_k_step = k_step[0];
        behave_s_step = s_step[0];
        behave_mu_angle = mu_angle[0];
        behave_k_angle = k_angle[0];
        // change the matrix used for choosing destination
        desMatrix = memShelterMatrix;
        break;
      case 1:
        behave_k_step = k_step[1];
        behave_s_step = s_step[1];
        behave_mu_angle = mu_angle[1];
        behave_k_angle = k_angle[1];
        break;
      case 2:
        behave_k_step = k_step[2];
        behave_s_step = s_step[2];
        behave_mu_angle = mu_angle[2];
        behave_k_angle = k_angle[2];
       // change the matrix used for choosing destination
        desMatrix = forageMatrix;
        break;
    // default:
    //   behave_k_step = k_step[0];
    //   behave_s_step = s_step[0];
    //   behave_mu_angle = mu_angle[0];
    //   behave_k_angle = k_angle[0];
    //   break;
    }
    Rcpp::Rcout << "-- Behaviour mode: " << behave_Locations[i] << " ---\n";

    // DESINTATION LOOP
    // Once behaviour is know, animal will chose it's next destination
    // if(i-1 % (12*60) == 0){ /// Test to see if we can pick out a new destination every 12 hours
    if(i == 1 | !behave_Locations[i] == behave_Locations[i-1]){
      for(int des = 0; des < ndes; des++){

        /* NEED A SCALING FACTOR TO ADJUST THE DISTANCES AVAILABLE FOR DRAWING THe
         DESINATIONS FROM */
        /* PLACEHOLDER INCREASE OF 10 FOR THE TIME BEING, FIX WILL REQUIRE
         SOMETHING TO UNITE TIME-SPACE-MOVEMENT */
        step = Rcpp::rgamma(1, behave_k_step*10, behave_s_step*2)[0];
        Rcpp::Rcout << "StepLength: " << step << "; ";

        /* PLACEHOLDER ALLOWING A DESINATION IN ANY DIRECTION,
         AGAIN AT THIS SCALE A LACK OF VELOCITY CORRELATION MAKES SENSE, BUT
         IDEALLY SOMETHING LIKE A TRANSLATION WOULD MAKE MORE SENSE*/
        vmdraw = cpp_vonmises(1, 0, 0.1)[0];
        Rcpp::Rcout << "VM ";
        angle = vmdraw * 180/M_PI;
        Rcpp::Rcout << "Angle: " << angle << "\n";

        // using the last location as start
        x_DesOptions[des] = x_Locations[i-1] + cos(angle) * step;
        y_DesOptions[des] = y_Locations[i-1] + sin(angle) * step;

        land_DesOptions = cpp_get_values(desMatrix, x_DesOptions, y_DesOptions);

        // Now the animal choses a location based on weighted choice
        chosenDes = cpp_sample_options(land_DesOptions, seeds[i-1]);

      }
    }

    // current distance from destination
    c_dist2 = std::pow((x_DesOptions[chosenDes] - x_Locations[i-1]), 2) +
      std::pow((y_DesOptions[chosenDes] - y_Locations[i-1]), 2);
    currDist = std::sqrt(c_dist2);
    desDist_Locations[i] = currDist;

    // MOVEMENT LOOP
    for(int j = 0; j < nopt; j++, a++){

      if(j == 0){
        /* for each step set the location as the previously chosen location */
        x_Options[0] = x_Locations[i-1];
        y_Options[0] = y_Locations[i-1];
        step_Options[0] = i;
        step_OptionsAll[a] = i; // this one needs assignment regardless
        continue;
      }

      if(currDist < 10){
        step = Rcpp::rgamma(1, behave_k_step/100, behave_s_step)[0];
        Rcpp::Rcout << "StepLength: " << step << "; ";

        vmdraw = cpp_vonmises(1, behave_mu_angle, behave_k_angle)[0];
        Rcpp::Rcout << "VM ";
        angle = vmdraw * 180/M_PI;
        Rcpp::Rcout << "Angle: " << angle << "\n";
      } else {
        step = Rcpp::rgamma(1, behave_k_step, behave_s_step)[0];
        Rcpp::Rcout << "StepLength: " << step << "; ";

        vmdraw = cpp_vonmises(1, behave_mu_angle, behave_k_angle)[0];
        Rcpp::Rcout << "VM ";
        angle = vmdraw * 180/M_PI;
        Rcpp::Rcout << "Angle: " << angle << "\n";
      }

      x_Options[j] = x_Options[0] + cos(angle) * step;
      y_Options[j] = y_Options[0] + sin(angle) * step;

      // add in which step the options are for
      step_Options[j] = i;

      // a is keeping tracking of the position in a ong vector steps*nopts
      x_OptionsAll[a] = x_Options[j];
      y_OptionsAll[a] = y_Options[j];
      step_OptionsAll[a] = i;

      // choice vector is needed for the sample function later on
      // choicesVec[j] = j;

    }

    move_Options = cpp_get_values(moveMatrix, x_Options, y_Options);

    // record the target destination at each time step
    desX_Locations[i] = x_DesOptions[chosenDes];
    desY_Locations[i] = y_DesOptions[chosenDes];
    /* here we need to adjust the movement objects so the animal prefers to head
     * towards the chosen destination.
     * a2 + b2 = c2
     */
    for(int k; k < nopt; k++){
      c_dist2 = std::pow((x_DesOptions[chosenDes] - x_Options[k]), 2) +
        std::pow((y_DesOptions[chosenDes] - y_Options[k]), 2);
      distance_toDes[k] = std::sqrt(c_dist2);
    }
    /* now we need to normalise the distances to something compatible with the
     * weighting for sample choice */
    // (xi – min(x)) / (max(x) – min(x))
    // find MIN
    double dist_min = distance_toDes[0];
    for(int l = 0; l < nopt; l++){
      if(distance_toDes[l] < dist_min){
        dist_min = distance_toDes[l];
      }
    }
    // find MAX
    double dist_max = distance_toDes[0];
    for(int l = 0; l < nopt; l++){
      if(distance_toDes[l] > dist_max){
        dist_max = distance_toDes[l];
      }
    }

    for(int m; m < nopt; m++){
      // first we have to invert it so ones closer to the destination are preferred
      distInvert = abs(distance_toDes[m] - dist_max);
      weights_toDes[m] = (distInvert - dist_min) /
        (dist_max - dist_min);
      // then combine them with the movement Matrix values
      move_Options[m] = move_Options[m] + (weights_toDes[m] *2);
    }

    /* using the custom sample_options, we need to feed it a different seed each time,
     * but overall those seeds are derived from the set.seed() in R prior to running
     * (see the R companion/set-up function .Call) */
    chosen = cpp_sample_options(move_Options, seeds[i-1]);

    // for testing, pick the first options always, should mean the animal never moves
    // chosen = 0;
    // moves every time
    // chosen = 1;
    // chosen = 2;

    chosen_Options[i] = chosen;

    x_Locations[i] = x_Options[chosen];
    y_Locations[i] = y_Options[chosen];
    step_Locations[i] = i;

  }
  Rcpp::List OUTPUT = Rcpp::List::create(
    // output the location data
    Rcpp::Named("loc_x") = x_Locations,
    Rcpp::Named("loc_y") = y_Locations,
    Rcpp::Named("loc_step") = step_Locations,
    Rcpp::Named("loc_behave") = behave_Locations,
    // output for destinations
    Rcpp::Named("desX") = desX_Locations,
    Rcpp::Named("desY") = desY_Locations,
    Rcpp::Named("desDist") = desDist_Locations,
    // output for all the optionsALL
    Rcpp::Named("oall_x") = x_OptionsAll,
    Rcpp::Named("oall_y") = y_OptionsAll,
    Rcpp::Named("oall_step") = step_OptionsAll,
    // output for the chosen options at each step
    Rcpp::Named("chosen") = chosen_Options,
    // output for the last options just to check
    Rcpp::Named("ol_x") = x_Options,
    Rcpp::Named("ol_y") = y_Options,
    Rcpp::Named("ol_moveVal1") = move_Options, // included to check probs used
    Rcpp::Named("ol_step") = step_Options // included to check is choice vector is the source of issues
  );
  return OUTPUT;

}
